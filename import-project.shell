#!/usr/bin/env bash
## Version: 0.1.0

export verbose='false';
export missing='is missing!';

function newline () { echo -e ""; return 0; };

## Objective: Displays a custom message.
function display_message () {
    ## echo -e "Tracking_process: ${FUNCNAME} ${@}";
    oIFS="${IFS}";
    for xitem in "${@}"; do
      IFS='='; set `echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'`
      [[ ${1#*\--} = "message" ]] && export message="${2}";
      [[ ${1#*\--} = "prefix" ]] && export prefix="${2}";
      [[ ${1#*\--} = "suffix" ]] && export suffix="${2}";
      #### ---------------------------------------------------------------------
      [[ ${1#*\--} = "interactive" ]] && export interactive_mode='true';
      ## [[ ${1#*\--} = "dry-run" ]] && export dry_run="${2}";
      [[ ${1#*\--} = "verbose" ]] && export verbose="${2}";
      [[ ${1#*\--} = "help" ]] && export display_help='true';
    done; IFS="${oIFS}";
    [[ ${#verbose} -eq 0 ]] && export verbose='true';
    #### -----------------------------------------------------------------------
    [[ ${#message} -eq 0 ]] && export message='';
    [[ ${#prefix} -eq 0 ]] && export prefix='';
    [[ ${#suffix} -eq 0 ]] && export suffix='';
    echo -e "${prefix}${message}${suffix}";
    return 0;
  }; alias display-message='display_message';

## Objective: Displays a warning message with optional error handling.
function warning () {
    ## echo -e "Tracking_process: ${FUNCNAME} ${@}";
    oIFS="${IFS}";
    for xitem in "${@}"; do
      IFS='='; set `echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'`
      [[ ${1#*\--} = "message" ]] && export message="${2}";
      [[ ${1#*\--} = "error" ]] && export error_id="${2}";
      #### ---------------------------------------------------------------------
      [[ ${1#*\--} = "interactive" ]] && export interactive_mode='true';
      ## [[ ${1#*\--} = "dry-run" ]] && export dry_run="${2}";
      [[ ${1#*\--} = "verbose" ]] && export verbose="${2}";
      [[ ${1#*\--} = "help" ]] && export display_help='true';
    done; IFS="${oIFS}";
    [[ ${#verbose} -eq 0 ]] && export verbose='true';
    #### -----------------------------------------------------------------------
    if [[ ${verbose} == true ]]; then
            suffix="\nError: ${error_id}";
      else  suffix='';
    fi;
    display_message --prefix="Warning: " \
                    --message="${message}" \
                    --suffix="${suffix}";
    newline;
    exit ${error_id};
  }; alias warning='warning';

## Objective: Parses the JSON configuration file and sets environment variables.
function import_config () {
    ## echo -e "Tracking_process: ${FUNCNAME} ${@}";
    oIFS="${IFS}";
    for xitem in "${@}"; do
      IFS='='; set `echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'`
      [[ ${1#*\--} = "config" ]] && export json_file="${2}";
      #### ---------------------------------------------------------------------
      [[ ${1#*\--} = "interactive" ]] && export interactive_mode='true';
      ## [[ ${1#*\--} = "dry-run" ]] && export dry_run="${2}";
      [[ ${1#*\--} = "verbose" ]] && export verbose="${2}";
      [[ ${1#*\--} = "help" ]] && export display_help='true';
    done; IFS="${oIFS}";
    [[ ${#verbose} -eq 0 ]] && export verbose='true';
    #### -----------------------------------------------------------------------
    ## Configure default-parameter(s):
    if [[ ${#json_file} -gt 0 ]]; then
            json_file="$(
              echo -e "${json_file}" \
              | sed -e "s|^\([\~\/]\)\(.*\)$|${HOME}\2|";
            )"
      else  ## Default JSON Configuration:
            json_file="${script_config}";
    fi;
    ## echo -e "JSON File: ${json_file}";
    header="JSON config";
    error=1;
    message="'${json_file}' ${missing}";
    if [[ ! -f "${json_file}" ]]; then
      warning --message="${header} ${message}" \
              --error=${error};
    fi;
    ## Parsing JSON Configuration:
    invalid=false;
    if [[ -f ${json_file} ]]; then
        json_config="$( jq -r '.' "${json_file}" )";
        if [[ ! -s "${json_config}" ]]; then
            newline;
            if [[ ${#reload} -eq 0 ]]; then
              export reload="$( echo -e "${json_config}" | jq -r '.reload' )";
            fi;
            if [[ ${#verbose} -eq 0 ]]; then
              export verbose="$( echo -e "${json_config}" | jq -r '.verbose' )";
            fi;
            export $(
              echo ${json_config} \
              | jq -r ".vendor|to_entries|map(\"vendor_\(.key)=\(.value|tostring)\")|.[]"
            );
            [[ ${verbose} == true ]] && {
              display_message --prefix="Import: " \
                              --message="${vendor_name}/${vendor_repo}@${vendor_commit}";
              # newline;
            };
            export $(
              echo -e "${json_config}" \
              | jq -r ".project|to_entries|map(\"project_\(.key)=\(.value|tostring)\")|.[]"
            );
            [[ ${verbose} == true ]] && {
              action_path=".github/actions/${project_action}";
              display_message --prefix="Project: " \
                              --message="${project_owner}/${project_repo}/${action_path}";
              newline;
            };
          else invalid=true;
        fi;
      else invalid=true;
    fi;
    ## Messaging empty/invalid JSON configuration:
    [[ "${invalid}" == true ]] && {
      error=2;
      warning --message="${header} ${message}" \
              --error=${error};
    };
    return 0;
  }; alias import-config='import_config';

## Objective: Manages cloning and purging of the GitHub repository.
function download_repository () {
    ## echo -e "Tracking_process: ${FUNCNAME} ${@}";
    oIFS="${IFS}";
    for xitem in "${@}"; do
      IFS='='; set `echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'`
      [[ ${1#*\--} = "config" ]] && export json_file="${2}";
      [[ ${1#*\--} = "github-repo" ]] && export github_repo="${2}";
      #### ---------------------------------------------------------------------
      [[ ${1#*\--} = "interactive" ]] && export interactive_mode='true';
      ## [[ ${1#*\--} = "dry-run" ]] && export dry_run="${2}";
      [[ ${1#*\--} = "verbose" ]] && export verbose="${2}";
      [[ ${1#*\--} = "help" ]] && export display_help='true';
    done; IFS="${oIFS}";
    [[ ${#verbose} -eq 0 ]] && export verbose='true';
    #### -----------------------------------------------------------------------
    if [[ $( pwd | egrep -c -w "${project_repo}" ) -eq 0 ]]; then
            error=3;
            request_action="Please, change current working directory.";
            warning --message="Project path '${project_path}' is not valid.\n${request_action}" \
                    --error=${error};
      else  pathway="$( echo -e "$(
              pwd | sed -e "s|${project_repo}||g" \
              | awk -F'//' '{print $1}'
            )/${project_path}" | sed -e 's|\/\/|/|' )";
            display_message --prefix="Pathway: " \
                            --message="${pathway}";
            newline;
            mkdir -p "${pathway}" && cd ${_};
            ls -al; newline;
    fi;
    ## Validate target location:
    if [[ ! -z "$( ls -A "${pathway}" )" ]]; then
       error=4;
       warning --message="Target path is not empty!" \
               --error=${error};
       newline;
       if [[ "${reload}" == true ]]; then
               display_message --prefix="Warning: " \
                               --message="Purging the existing content is set to '${reload}'";
               newline;
               rm -rfv ${pathway}/* ${pathway}/.*;
         else  error=5;
               return ${error};
       fi;
    fi;
    ## Identifying current/active branch:
    current_branch="$( git rev-parse --abbrev-ref HEAD )";
    if [[ ${current_branch} =~ 'main|master' ]]; then
            request_action="Aborting current operations.";
            error=6;
            warning --message="Current branch is '${current_branch}'!\n${request_action}" \
                    --error=${error};
      else  checkout="${project_team}/${project_author}/${project_action}";
            display_message --prefix="Checkout branch: " \
                            --message="${checkout}";
            newline;
            git checkout "${checkout}" 2>/dev/null;
            if [[ ${?} -eq 0 ]]; then
              git status; newline;
            fi;
    fi;
    ## Cloning Target GitHub Repository:
    display_message --prefix="Cloning repo: " \
                    --message="${github_repo}";
    newline;
    git clone "${github_repo}" .;
    ## Determine if a specific hash-commit is required/provided:
    if [[ "${#vendor_commit}" -gt 0 ]]; then
      display_message --prefix="\nWarning: " \
                      --message="Performing GitHub hard-reset.";
      newline;
      git reset --hard "${vendor_commit}" 2>/dev/null;
      if [[ ${?} -gt 0 ]]; then
              display_message --prefix="Warning: " \
                              --message="Unable to read tree or parse object " \
                              --suffix="${vendor_commit}";
        else  display_message --message="Listing Git-log summary: ...";
              newline;
              git log --graph --decorate --pretty=oneline --abbrev-commit;
      fi;
    fi;
    ## Isolating .git and .gitignore paths:
    mv .git _git 2>/dev/null;
    mv .github _github 2>/dev/null;
    ## Excluding .git and .gitignore paths:
    touch .gitignore 2>/dev/null;
    declare -a items=( .git _git .github _github );
    for item in ${items[@]}; do
      if [[ $( egrep -w "${item}" .gitignore ) -eq 0 ]]; then
        echo -e "${item}" >> .gitignore;
      fi;
    done;
    ## Parsing local-repository state:
    newline;
    git status;
    git add .;
    newline;
    git status;
    ## Initializing import clone:
    display_message --message="Importing default repository configuration";
    newline;
    git commit -m "Importing ${vendor_name}/${vendor_repo} default state.";
    newline;
    git status;
    newline;
    ls -al;
    return 0;
  }; alias download-repository='download_repository';

## Objective: Processes the repository files and updates content based on the configuration.
function import_project () {
    ## echo -e "Tracking_process: ${FUNCNAME} ${@}";
    oIFS="${IFS}";
    for xitem in "${@}"; do
      IFS='='; set `echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'`
      [[ ${1#*\--} = "git-owner" ]] && export __vendor_name="${2}";
      [[ ${1#*\--} = "git-name" ]] && export __vendor_repo="${2}";
      [[ ${1#*\--} = "git-version" ]] && export __vendor_version="${2}";
      [[ ${1#*\--} = "git-commit" ]] && export __vendor_commit="${2}";
      [[ ${1#*\--} = "git-org" ]] && export __project_owner="${2}";
      [[ ${1#*\--} = "git-repo" ]] && export __project_repo="${2}";
      [[ ${1#*\--} = "git-action" ]] && export __project_action="${2}";
      #### ---------------------------------------------------------------------
      [[ ${1#*\--} = "interactive" ]] && export interactive_mode='true';
      ## [[ ${1#*\--} = "dry-run" ]] && export dry_run="${2}";
      [[ ${1#*\--} = "verbose" ]] && export verbose="${2}";
      ## Parsing all Help-request features:
      [[ ${1#*\--} = "help" ]] && export display_help='true';
      [[ ${1#*\--} = "examples" ]] && local example_mode='true';
      [[ ${1#*\--} = "wizard" ]] && local wizard_mode='true';
      [[ ${1#*\--} = "info" ]] && local info_mode='true';
    done; IFS="${oIFS}";
    [[ ${#verbose} -eq 0 ]] && export verbose='true';
    ## Prividing operational assistance (helper)
    if [[ ( ${display_help} == 'true' )   || \
          ( ${example_mode} == 'true' ) || \
          ( ${wizard_mode} == 'true' )  || \
          ( ${info_mode} == 'true' )
      ]]; then
      ## JSON source and object:
      helper_module="emvaldes/devops-scripts/master/script-helper.shell";
      ## display_message --message="Loading the Script-helper for built-in support ...";
      # source ${script_helper} 2>/dev/null;
      source <(
        curl -s https://raw.githubusercontent.com/${helper_module}
      ) 2>/dev/null;
      if declare -F script_helper > /dev/null; then
              ## display_message --message="Loaded Script-Helper in memory!";
              script_helper --caller="${script_file}" \
                            --examples=${example_mode} \
                            --wizard=${wizard_mode} \
                            --info=${info_mode} \
              ;
              return 1;
        else  warning --message="Script Helper was not found!" \
                      --error=2;
      fi;
      ## Aborting script's execution.
      exit 0;
    fi;
    #### -----------------------------------------------------------------------
    ## Configure default-parameter(s):
    header="Vendor Name";
    if [[ ${#__vendor_name} -gt 0 ]]; then
      export vendor_name="${__vendor_name}";
    fi;
    display_message --prefix="${header}: " --message="${vendor_name}";
    header="Vendor Repository";
    if [[ ${#__vendor_repo} -gt 0 ]]; then
      export vendor_repo="${__vendor_repo}";
    fi;
    display_message --prefix="${header}: " --message="${vendor_repo}";
    header="Vendor Version";
    if [[ ${#__vendor_version} -gt 0 ]]; then
      export vendor_version="${__vendor_version}";
    fi;
    display_message --prefix="${header}: " --message="${vendor_version}";
    header="Vendor Commit";
    if [[ ${#__vendor_commit} -gt 0 ]]; then
      export vendor_commit="${__vendor_commit}";
    fi;
    display_message --prefix="${header}: " --message="${vendor_commit}";
    header="Project Owner";
    if [[ ${#__project_owner} -gt 0 ]]; then
      export project_owner="${__project_owner}";
    fi;
    display_message --prefix="${header}: " --message="${project_owner}";
    header="Project Repo";
    if [[ ${#__project_repo} -gt 0 ]]; then
      export project_repo="${__project_repo}";
    fi;
    display_message --prefix="${header}: " --message="${project_repo}";
    header="GitHub Action";
    if [[ ${#__project_action} -gt 0 ]]; then
      export project_action="${__project_action}";
    fi;
    display_message --prefix="${header}: " --message="${project_action}";
    ## GitHub Remote/External Repository:
    export github_repo="https://github.com/${vendor_name}/${vendor_repo}.git";
    #### -----------------------------------------------------------------------
    newline;
    ## Downloading GitHub Repository:
    export project_path="${project_repo}/.github/actions/${project_action}";
    #### -----------------------------------------------------------------------
    ## Downloading Remote/External Repository:
    download_repository --github-repo="${github_repo}";
    ## Aborting processing:
    if [[ ${?} -gt 0 ]]; then exit ${?}; fi;
    #### -----------------------------------------------------------------------
    ## Constructing List-Of-Files:
    declare -a files=($(
      find . -type f \
             -not -path '*/.git/*' -not -path '*/.github/*' \
             -not -path '*/_git/*' -not -path '*/_github/*' \
           ! -name "${script_name}" ! -name "${script_config}" \
      | xargs -I {} egrep -Hni "${vendor_name}" {} \
      | awk -F':' '{print $1}' \
      | sort -u
    )) ;
    #### -----------------------------------------------------------------------
    ## Listing List-Of-Files:
    display_message --message="Listing Target-Files ...";
    newline;
    for file in ${files[@]}; do echo -e "File: ${file}"; done;
    newline;
    #### -----------------------------------------------------------------------
    ## Parsing Target Files:
    for file in ${files[@]}; do
      sed -i '' \
          -e "s|\(${vendor_name}/${vendor_repo}/actions/\)|${project_owner}/${project_path}/|gi" \
          -e "s|${vendor_name}/${vendor_repo}|${project_owner}/${project_path}|gi" \
          -e "s|${vendor_version}|${vendor_commit}|gi" \
          -e "s|actions/${project_action}/workflows/|workflows/${project_action}--|gi" \
      ${file};
    done ;
    git status; newline;
    git add . && git commit -m "Appending default configuration changes.";
    git status; newline;
    #### -----------------------------------------------------------------------
    return 0;
  }; alias import-project='import_project';

## Backing-up Application Input-params:
export params="${@}";

export script_file="$(pwd)/${0#*\/}";
export script_path="$( dirname "${0}" )";
## echo -e "Script Path: ${script_path}";

export script_name="$( basename "${0}" )";
## echo -e "Script Name: ${script_name}";

export script_helper="${script_path}/script-helper.shell";
## echo -e "Script Helper: ${script_helper}";

## Deprecating this implementation for operational flexibility (decoupling):
## export script_config="${script_path}/${script_name/.*/.json}";
export script_config="${script_path}/project-config.json";
## echo -e "Script Config: ${script_config}";

## Executing script's workflow:
import_config "${@}";
import_project "${@}";

## import-reository \
##   --git-owner="JosiahSiegel" \
##   --git-name="AzViz-action" \
##   --git-version="v1.0.3" \
##   --git-commit="663e24299a6336f1ff8dbddadfac1ba5d462f731";
##   --git-org="CDCgov" \
##   --git-repo="prime-reportstream"  \
##   --git-actoin="azviz" \
##;

## import-reository --config="import.json";
